with builtins;
let
    source = import ./.;
    flake_info = let
        versionSuffix = readFile (source.nix_path + "/.version-suffix");
        versionParts = filter (part: part != []) (split "\\." versionSuffix);
        number = elemAt versionParts 1;
        shortRevision = elemAt versionParts 2;
        fullRevision = readFile (source.nix_path + "/.git-revision");
        in {
            rev = fullRevision;
            shortRev = shortRevision;
            lastModifiedDate = number;
        };
    nixpkgs = source.value.outputs { self = nixpkgs; } // {
        # If you import the outPath, it should result in 'old' nixpkgs. See https://stackoverflow.com/a/74465514
        outPath = source.nix_path;
        
        # Fake some stuff to make lib/flake-version-info.nix return the same values
        # as before we used the flake. Because we're not _really_ using flakes (yet),
        # the flake version info otherwise gives a weird store path
        # (like nixos-system-ferrix-24.05.19700101.dirty).
        # See https://nix.dev/manual/nix/2.24/command-ref/new-cli/nix3-flake.html#flake-references
        # for some of these 'magic' attrs that the flakes system usually sets.
        inherit (flake_info) rev shortRev lastModifiedDate;
    };
in {
    outPath = nixpkgs.outPath;
    
    pins.nixpkgs = {
        # Pins are a capsule output that aims to make our pinning mechanisme
        # visible. This attrset should probably be easy to strictly evaluate
        # and fully print (so no lambdas or whole import results for instance).
        # They should provide a way to update their 'locks' (currently the
        # default.nix generated by the update script).
        channel_url = readFile ./channel_url;
    };
    
    packages = {
        x86_64-linux = nixpkgs.legacyPackages.x86_64-linux;
        aarch64-linux = nixpkgs.legacyPackages.aarch64-linux;
    };

    inherit (nixpkgs) lib nixosModules;
    
}
