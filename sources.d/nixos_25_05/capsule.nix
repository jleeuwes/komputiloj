{ platform, boltons }:
with boltons.lib;
let
    localSystem = platform.localSystem;
    allowedUnfreePackages = [
        "steam" "steam-unwrapped" "steam-run" "steam-original"
        "android-studio"
    ];
    source = import ./.;
    nixpkgs_nonflake = source.value_nonflake;
    nixpkgs_lib = import (source.nix_path + "/lib");
    nixpkgs_nixos_lib_eval-config = import (source.nix_path + "/nixos/lib/eval-config.nix");
    nixpkgs_config = {
        allowUnfreePredicate = pkg:
            elem (nixpkgs_lib.getName pkg) allowedUnfreePackages;
    };
in rec {
    # If you import the outPath, it should result in 'old' nixpkgs. See https://stackoverflow.com/a/74465514
    # (not sure if still applicable when not going through flake)
    outPath = source.nix_path;
    
    pins.nixpkgs = {
        # Pins are a capsule output that aims to make our pinning mechanisme
        # visible. This attrset should probably be easy to strictly evaluate
        # and fully print (so no lambdas or whole import results for instance).
        # They should provide a way to update their 'locks' (currently the
        # default.nix generated by the update script).
        channel_url = readFile ./channel_url;
    };

    # commands: system is the system on which the command should run.
    #           so always the local system (currently).
    #           to not overload the meaning of the systems in each output,
    #           we should have a per-system layer for commands!
    # packages: system is the system on which the package will be used
    #           as a 'regular' package. they are built on the local system.
    #           if the local system is implicit here it should also be
    #           implicit for commands!
    #           on what system they are built (emulated or not)
    #           is conceptually not relevant (you just want to 'use'
    #           them on a machine that has some system)
    #           but might be relevant in practice
    #           (caching of build outputs, leaky cross compilation maybe)
    #           so we should NOT put emulated in the names here
    # buildTools: system is the system for which we are building.
    #           buildTools are built and run on the local system.
    #           note that they are not used used by nixpgks/nixos,
    #           because we have no hope on passing those all the way
    #           through nixpkgs. they are meant for packages in our
    #           own capsules.
    #           buildTools should be directly buildable derivations,
    #           not functions! we call those recipes.
    #           (the name buildTools is inspired by
    #           https://github.com/NixOS/nixpkgs/issues/28327#issuecomment-879815573;
    #           we don't use components, which is a good name for a dependency declaration
    #           but too broad a name for a thing that is can be used. also packages
    #           is adequate for this and has more or less the same meaning as in flakes,
    #           so it's okay to reuse that name)
    # recipes: functions returning a derivation
    #           the term recipes come from
    #           https://archive.fosdem.org/2024/schedule/event/fosdem-2024-3107-units-of-composition-recipes-overlays-and-packages/
    #           (some discussion I have not read at
    #           https://discourse.nixos.org/t/new-reader-finding-documentation-unnecessarily-confusing/40722/6

    legacyBuildTools = {
        # NOTE: only cross is interesting, the rest is really the same as legacyPackages
        native = mapAttrs (nm: pkgs: pkgs.pkgsBuildHost) legacyPackages.native;
        qemu   = mapAttrs (nm: pkgs: pkgs.pkgsBuildHost) legacyPackages.qemu;
        cross  = mapAttrs (nm: pkgs: pkgs.pkgsBuildHost) legacyPackages.cross;
    };
    
    legacyPackages = {
        native = {
            ${localSystem} = nixpkgs_nonflake {
                system = localSystem;
                config = nixpkgs_config;
            };
        };

        qemu = let
            gensystem = system:
                if elem system platform.emulatedSystems
                then nixpkgs_nonflake {
                    inherit system;
                    config = nixpkgs_config;
                } else throw "Please add ${system} to binfmt.emulatedSystem";
        in removeAttrs {
            x86_64-linux  = gensystem "x86_64-linux";
            aarch64-linux = gensystem "aarch64-linux";
        } [ localSystem ];

        cross = let
            gensystem = system: nixpkgs_nonflake {
                system = localSystem;
                crossSystem = system;
                config = nixpkgs_config;
            };
        in removeAttrs {
            x86_64-linux  = gensystem "x86_64-linux";
            aarch64-linux = gensystem "aarch64-linux";
        } [ localSystem ];
    };

    packages = let
        # TODO: discover packages in attrsets and flatten them?
        #       remember: we only want to expose packages.${system}.${pkgname}, nothing deeper!
        # TODO: put functions that return a derivation in recipes? (this is hard to detect.)
        # TODO: do this at pin update time, because it is costly
        realPackages = pkgs: let
            select = attr: let tried = tryEval (nixpkgs_lib.isDerivation attr.value); in tried.success && tried.value;
        in filterAttrs select pkgs;
    in {
        # TODO same structure with native/qemu/cross as legacyPackages
    };

    lib = nixpkgs_lib // {
        nixosSystem = { modules, pkgs }:
            nixpkgs_nixos_lib_eval-config {
                system = null;
                lib = nixpkgs_lib; # don't let eval-config.nix reimport lib
                extraModules = []; # disable some env-dependent stuff
                modules = modules ++ [{
                    # We want nixosSystem to always get an explicit pkgs parameter.
                    # But we pass it modularly because the pkgs parameter of eval-config.nix is sort of deprecated.
                    nixpkgs.pkgs = pkgs;
                    
                    # TODO: check that nixpkgs checks the system of pkgs against nixpkgs.hostPlatform (usually in hardware-configuration.nix)
                    # If not, maybe this will help to produce a nice module option conflict error:
                    # nixpkgs.hostPlatform = pkgs.stdenv.hostPlatform.system;
                }];
            };
    };

    # inherit (nixpkgs_flake) nixosModules;
    
}
