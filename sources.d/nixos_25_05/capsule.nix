with builtins;
let
    source = import ./.;
    flake_info = let
        versionSuffix = readFile (source.nix_path + "/.version-suffix");
        versionParts = filter (part: part != []) (split "\\." versionSuffix);
        number = elemAt versionParts 1;
        shortRevision = elemAt versionParts 2;
        fullRevision = readFile (source.nix_path + "/.git-revision");
        in {
            rev = fullRevision;
            shortRev = shortRevision;
            lastModifiedDate = number;
        };
    nixpkgs = source.value.outputs { self = nixpkgs; } // {
        # If you import the outPath, it should result in 'old' nixpkgs. See https://stackoverflow.com/a/74465514
        outPath = source.nix_path;
        
        # Fake some stuff to make lib/flake-version-info.nix return the same values
        # as before we used the flake. Because we're not _really_ using flakes (yet),
        # the flake version info otherwise gives a weird store path
        # (like nixos-system-ferrix-24.05.19700101.dirty).
        # See https://nix.dev/manual/nix/2.24/command-ref/new-cli/nix3-flake.html#flake-references
        # for some of these 'magic' attrs that the flakes system usually sets.
        inherit (flake_info) rev shortRev lastModifiedDate;
    };
in
{ platform }:
let localSystem = platform.localSystem;
in {
    outPath = nixpkgs.outPath;
    
    pins.nixpkgs = {
        # Pins are a capsule output that aims to make our pinning mechanisme
        # visible. This attrset should probably be easy to strictly evaluate
        # and fully print (so no lambdas or whole import results for instance).
        # They should provide a way to update their 'locks' (currently the
        # default.nix generated by the update script).
        channel_url = readFile ./channel_url;
    };

    # commands: system is the system on which the command should run.
    #           so always the local system (currently).
    #           to not overload the meaning of the systems in each output,
    #           we should have a per-system layer for commands!
    # packages: system is the system on which the package will be used
    #           as a 'regular' package. they are built on the local system.
    #           if the local system is implicit here it should also be
    #           implicit for commands!
    #           on what system they are built (emulated or not)
    #           is conceptually not relevant (you just want to 'use'
    #           them on a machine that has some system)
    #           but might be relevant in practice
    #           (caching of build outputs, leaky cross compilation maybe)
    #           so we should NOT put emulated in the names here
    # buildTools: system is the system for which we are building.
    #             buildTools are built and run on the local system.
    #             note that they are not used within this capsule,
    #             because we have no hope on passing those all the way
    #             through nixpkgs. they are meant for packages in our
    #             own capsules.
    #             buildTools should be directly buildable derivations,
    #             not functions! we call those buildRecipes.
    # (the name buildTools is inspired by
    # https://github.com/NixOS/nixpkgs/issues/28327#issuecomment-879815573;
    # we don't use components, which is a good name for a dependency declaration
    # but too broad a name for a thing that is can be used. also packages
    # is adequate for this and has more or less the same meaning as in flakes,
    # so it's okay to reuse that name)
    # recipes: functions that return packages
    # buildRecipes: functions that return buildTools
    # TODO: the term recipes come from a talk, but I'm not sure, maybe
    # it was a different term. hopefully I can find back the talk someday.

    buildTools = {
        # the only buildTools we can provide unemulated are those for the
        # system komputiloj runs on
        ${localSystem} = nixpkgs.legacyPackages.${localSystem};
        aarch64-linux-emulated = nixpkgs.legacyPackages.aarch64-linux;
        # echte aarch64-linux gaat niet lukken zolang we via de nixpkgs-flake
        # gaan, want die stelt localPlatform en crossPlatform gelijk
    };
    
    packages = {
        # this is okay as long as we only build things on x86_64-linux.
        # in the unlikely event that we were to run komputiloj on, say, a
        # raspberry pi, this would result in emulation
        x86_64-linux = nixpkgs.legacyPackages.x86_64-linux;
        
        # this is where the choice is made to do an emulated
        # build on non-aarch64 (vs a cross compile)
        # maybe emulation vs cross should be an option that this capsule
        # receives? we would have to go through nixpkgs proper to do cross
        # compilation
        aarch64-linux = nixpkgs.legacyPackages.aarch64-linux;
    };

    inherit (nixpkgs) lib nixosModules;
    
}
