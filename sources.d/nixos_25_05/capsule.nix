{ platform, boltons }:
with boltons.lib;
let
    localSystem = platform.localSystem;
    allowedUnfreePackages = [
        "steam" "steam-unwrapped" "steam-run" "steam-original"
        "android-studio"
    ];
    source = import ./.;
    nixpkgs_nonflake = source.value_nonflake;
    nixpkgs_lib = import (source.nix_path + "/lib");
    nixpkgs_nixos_lib_eval-config = import (source.nix_path + "/nixos/lib/eval-config.nix");
in rec {
    # If you import the outPath, it should result in 'old' nixpkgs. See https://stackoverflow.com/a/74465514
    # (not sure if still applicable when not going through flake)
    outPath = source.nix_path;
    
    pins.nixpkgs = {
        # Pins are a capsule output that aims to make our pinning mechanisme
        # visible. This attrset should probably be easy to strictly evaluate
        # and fully print (so no lambdas or whole import results for instance).
        # They should provide a way to update their 'locks' (currently the
        # default.nix generated by the update script).
        channel_url = readFile ./channel_url;
    };

    # commands: system is the system on which the command should run.
    #           so always the local system (currently).
    #           to not overload the meaning of the systems in each output,
    #           we should have a per-system layer for commands!
    # packages: system is the system on which the package will be used
    #           as a 'regular' package. they are built on the local system.
    #           if the local system is implicit here it should also be
    #           implicit for commands!
    #           on what system they are built (emulated or not)
    #           is conceptually not relevant (you just want to 'use'
    #           them on a machine that has some system)
    #           but might be relevant in practice
    #           (caching of build outputs, leaky cross compilation maybe)
    #           so we should NOT put emulated in the names here
    # buildTools: system is the system for which we are building.
    #           buildTools are built and run on the local system.
    #           note that they are not used used by nixpgks/nixos,
    #           because we have no hope on passing those all the way
    #           through nixpkgs. they are meant for packages in our
    #           own capsules.
    #           buildTools should be directly buildable derivations,
    #           not functions! we call those recipes.
    #           (the name buildTools is inspired by
    #           https://github.com/NixOS/nixpkgs/issues/28327#issuecomment-879815573;
    #           we don't use components, which is a good name for a dependency declaration
    #           but too broad a name for a thing that is can be used. also packages
    #           is adequate for this and has more or less the same meaning as in flakes,
    #           so it's okay to reuse that name)
    # recipes: functions returning a derivation
    #           the term recipes come from
    #           https://archive.fosdem.org/2024/schedule/event/fosdem-2024-3107-units-of-composition-recipes-overlays-and-packages/
    #           (some discussion I have not read at
    #           https://discourse.nixos.org/t/new-reader-finding-documentation-unnecessarily-confusing/40722/6

    # TODO uitsplitsen in buildTools, crossBuildTools and emulatedBuildTools?
    buildTools = {
        # the only buildTools we can provide unemulated are
        # those for the system komputiloj runs on
        ${localSystem} = legacyPackages.${localSystem};
        aarch64-linux-emulated = legacyPackages.aarch64-linux;
        # echte aarch64-linux gaat niet lukken zolang we via de nixpkgs-flake
        # gaan, want die stelt localPlatform en crossPlatform gelijk
    };
    
    legacyPackages = {
        # this is okay as long as we only build things on x86_64-linux.
        # in the unlikely event that we were to run komputiloj on, say, a
        # raspberry pi, this would result in emulation
        x86_64-linux = nixpkgs_nonflake {
            system = "x86_64-linux";
            config = {
                allowUnfreePredicate = pkg:
                    elem (nixpkgs_lib.getName pkg) allowedUnfreePackages;
            };
        };
        
        # these packages are built using emulation
        # on non-aarch64 (versus cross compiled).
        # this is what flakes do in their legacyPackages output,
        # let's not deviate from that in flakes-defined outputs.
        # we have a separate crossLegacyPackages output for cross compilation.
        aarch64-linux = nixpkgs_nonflake {
            system = "aarch64-linux";
            config = {
                allowUnfreePredicate = pkg:
                    elem (nixpkgs_lib.getName pkg) allowedUnfreePackages;
            };
        };
    };

    crossLegacyPackages = {
        aarch64-linux = nixpkgs_nonflake {
            system = localSystem;
            crossSystem = "aarch64-linux";
            config = {
                allowUnfreePredicate = pkg:
                    elem (nixpkgs_lib.getName pkg) allowedUnfreePackages;
            };
        };
    };

    packages = let
        # TODO: discover packages in attrsets and flatten them?
        #       remember: we only want to expose packages.${system}.${pkgname}, nothing deeper!
        # TODO: put functions that return a derivation in recipes? (this is hard to detect.)
        # TODO: do this at pin update time, because it is costly
        realPackages = pkgs: let
            select = attr: let tried = tryEval (nixpkgs_lib.isDerivation attr.value); in tried.success && tried.value;
        in filterAttrs select pkgs;
    in {
        # same notes about emulation vs cross-compilations apply as those with legacyPackages
        x86_64-linux = realPackages legacyPackages.x86_64-linux;
        aarch64-linux = realPackages legacyPackages.aarch64-linux;
    };

    crossPackages = {
        aarch64-linux = {
            # TODO buildPlatform = localSystem, hostPlatform = aarch64-linux
        };
    };

    lib = nixpkgs_lib // {
        nixosSystem = { modules, pkgs }:
            nixpkgs_nixos_lib_eval-config {
                system = null;
                lib = nixpkgs_lib; # don't let eval-config.nix reimport lib
                extraModules = []; # disable some env-dependent stuff
                modules = modules ++ [{
                    # We want nixosSystem to always get an explicit pkgs parameter.
                    # But we pass it modularly because the pkgs parameter of eval-config.nix is sort of deprecated.
                    nixpkgs.pkgs = pkgs;
                    
                    # TODO: check that nixpkgs checks the system of pkgs against nixpkgs.hostPlatform (usually in hardware-configuration.nix)
                    # If not, maybe this will help to produce a nice module option conflict error:
                    # nixpkgs.hostPlatform = pkgs.stdenv.hostPlatform.system;
                }];
            };
    };

    # inherit (nixpkgs_flake) nixosModules;
    
}
