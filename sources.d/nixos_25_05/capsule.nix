with builtins;
let
    source = import ./.;
    flake_info = let
        versionSuffix = readFile (source.nix_path + "/.version-suffix");
        versionParts = filter (part: part != []) (split "\\." versionSuffix);
        number = elemAt versionParts 1;
        shortRevision = elemAt versionParts 2;
        fullRevision = readFile (source.nix_path + "/.git-revision");
        in {
            rev = fullRevision;
            shortRev = shortRevision;
            lastModifiedDate = number;
        };
    nixpkgs = source.value.outputs { self = nixpkgs; } // {
        # If you import the outPath, it should result in 'old' nixpkgs. See https://stackoverflow.com/a/74465514
        outPath = source.nix_path;
        
        # Fake some stuff to make lib/flake-version-info.nix return the same values
        # as before we used the flake. Because we're not _really_ using flakes (yet),
        # the flake version info otherwise gives a weird store path
        # (like nixos-system-ferrix-24.05.19700101.dirty).
        # See https://nix.dev/manual/nix/2.24/command-ref/new-cli/nix3-flake.html#flake-references
        # for some of these 'magic' attrs that the flakes system usually sets.
        inherit (flake_info) rev shortRev lastModifiedDate;
    };
in
{ platform }:
let localSystem = platform.localSystem;
in {
    outPath = nixpkgs.outPath;
    
    pins.nixpkgs = {
        # Pins are a capsule output that aims to make our pinning mechanisme
        # visible. This attrset should probably be easy to strictly evaluate
        # and fully print (so no lambdas or whole import results for instance).
        # They should provide a way to update their 'locks' (currently the
        # default.nix generated by the update script).
        channel_url = readFile ./channel_url;
    };

    # commands: system is the system on which the command should run.
    #           so always the local system (currently).
    #           to not overload the meaning of the systems in each output,
    #           we should have a per-system layer for commands!
    # packages: system is the system on which the package will be used
    #           as a 'regular' package. they are built on the local system.
    #           if the local system is implicit here it should also be
    #           implicit for commands!
    #           on what system they are built (emulated or not)
    #           is conceptually not relevant (you just want to 'use'
    #           them on a machine that has some system)
    #           but might be relevant in practice
    #           (caching of build outputs, leaky cross compilation maybe)
    #           so we should NOT put emulated in the names here
    # buildTools: system is the system for which we are building.
    #           buildTools are built and run on the local system.
    #           note that they are not used used by nixpgks/nixos,
    #           because we have no hope on passing those all the way
    #           through nixpkgs. they are meant for packages in our
    #           own capsules.
    #           buildTools should be directly buildable derivations,
    #           not functions! we call those recipes.
    #           (the name buildTools is inspired by
    #           https://github.com/NixOS/nixpkgs/issues/28327#issuecomment-879815573;
    #           we don't use components, which is a good name for a dependency declaration
    #           but too broad a name for a thing that is can be used. also packages
    #           is adequate for this and has more or less the same meaning as in flakes,
    #           so it's okay to reuse that name)
    # recipes: functions returning a derivation
    #           the term recipes come from
    #           https://archive.fosdem.org/2024/schedule/event/fosdem-2024-3107-units-of-composition-recipes-overlays-and-packages/
    #           (some discussion I have not read at
    #           https://discourse.nixos.org/t/new-reader-finding-documentation-unnecessarily-confusing/40722/6

    buildTools = {
        # the only buildTools we can provide unemulated are
        # those for the system komputiloj runs on
        ${localSystem} = nixpkgs.legacyPackages.${localSystem};
        aarch64-linux-emulated = nixpkgs.legacyPackages.aarch64-linux;
        # echte aarch64-linux gaat niet lukken zolang we via de nixpkgs-flake
        # gaan, want die stelt localPlatform en crossPlatform gelijk
    };
    
    # buildRecipes is a bad name.
    # buildRecipes suggest that the results are buildTools.
    # but the nixosSystem does not run on the build system, so the build prefix
    # would not mean the same as in buildTools.
    # also, nixosSystem does not even return a derivation and can't be 'run'.
    # (I don't think we even need a buildRecipes output, even if it would
    # contain the correct things; recipes should be enough for everything I
    # would think)
    shouldNotBeCalled_buildRecipes = {
        # TODO reuse pkgs in the nixosSystem calls
        ${localSystem} = {
            nixosSystem = { modules }: nixpkgs.lib.nixosSystem {
                system = null;
                lib = nixpkgs.lib;
                modules = modules ++ [{
                    nixpkgs.buildPlatform.system = localSystem;
                    nixpkgs.hostPlatform.system  = localSystem;
                }];
            };
        };
        aarch64-linux-emulated = {
            # NOT YET TESTED
            nixosSystem = { modules }: nixpkgs.lib.nixosSystem {
                system = null;
                lib = nixpkgs.lib;
                modules = modules ++ [{
                    nixpkgs.buildPlatform.system = "aarch64-linux";
                    nixpkgs.hostPlatform.system  = "aarch64-linux";
                }];
            };
        };
        aarch64-linux-cross = {
            # NOT YET TESTED
            nixosSystem = { modules }: nixpkgs.lib.nixosSystem {
                system = null;
                lib = nixpkgs.lib;
                modules = modules ++ [{
                    nixpkgs.buildPlatform.system = localSystem;
                    nixpkgs.hostPlatform.system  = "aarch64-linux";
                }];
            };
        };
    };
    
    packages = {
        # this is okay as long as we only build things on x86_64-linux.
        # in the unlikely event that we were to run komputiloj on, say, a
        # raspberry pi, this would result in emulation
        x86_64-linux = nixpkgs.legacyPackages.x86_64-linux;
        
        # these packages are built using emulation
        # on non-aarch64 (versus cross compiled).
        # this is what flakes do in their packages output,
        # let's not deviate from that in flakes-defined outputs.
        # we have a separate crossPackages output for cross compilation.
        aarch64-linux = nixpkgs.legacyPackages.aarch64-linux;
    };

    crossPackages = {
        aarch64-linux = {
            # TODO buildPlatform = localSystem, hostPlatform = aarch64-linux
        };
    };

    lib = nixpkgs.lib // {
        nixosSystem = args:
            # system should not default to impure currentSystem but it does :|
            nixpkgs.lib.nixosSystem (args // { extraModules = []; });
    };

    inherit (nixpkgs) nixosModules;
    
}
