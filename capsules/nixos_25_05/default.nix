{ boltons, platform }:
with boltons.lib;
let
localSystem = platform.localSystem;
allowedUnfreePackages = [
    "steam" "steam-unwrapped" "steam-run" "steam-original"
    "android-studio"
];

# Pins are a capsule output that aims to make our pinning mechanisme
# visible. This attrset should probably be easy to strictly evaluate
# and fully print (so no lambdas or whole import results for instance).
# They should provide a way to update their 'locks' (currently the
# default.nix generated by the update script).
pins = importDirAndApply ./pins.d {
    lib = self.lib;
    legacyPackages = self.native.${platform.localSystem}.legacyPackages;
};

lock = pins.nixpkgs.lock;
nixpkgs_nonflake = import lock.nix_path;
nixpkgs_lib = import (lock.nix_path + "/lib");
nixpkgs_nixos_lib_eval-config = import (lock.nix_path + "/nixos/lib/eval-config.nix");
nixpkgs_config = {
    allowUnfreePredicate = pkg:
        elem (nixpkgs_lib.getName pkg) allowedUnfreePackages;
};
self = {
    # If you import the outPath, it should result in 'old' nixpkgs. See https://stackoverflow.com/a/74465514
    # (not sure if still applicable when not going through flake)
    outPath = lock.nix_path;

    inherit pins;

    # commands: system is the system on which the command should run.
    #           so always the local system (currently).
    #           to not overload the meaning of the systems in each output,
    #           we should have a per-system layer for commands!
    # packages: system is the system on which the package will be used
    #           as a 'regular' package. they are built on the local system.
    #           if the local system is implicit here it should also be
    #           implicit for commands!
    #           on what system they are built (emulated or not)
    #           is conceptually not relevant (you just want to 'use'
    #           them on a machine that has some system)
    #           but might be relevant in practice
    #           (caching of build outputs, leaky cross compilation maybe)
    #           so we should NOT put emulated in the names here
    # buildTools: system is the system for which we are building.
    #           buildTools are built and run on the local system.
    #           note that they are not used used by nixpgks/nixos,
    #           because we have no hope on passing those all the way
    #           through nixpkgs. they are meant for packages in our
    #           own capsules.
    #           buildTools should be directly buildable derivations,
    #           not functions! we call those recipes.
    #           (the name buildTools is inspired by
    #           https://github.com/NixOS/nixpkgs/issues/28327#issuecomment-879815573;
    #           we don't use components, which is a good name for a dependency declaration
    #           but too broad a name for a thing that is can be used. also packages
    #           is adequate for this and has more or less the same meaning as in flakes,
    #           so it's okay to reuse that name)
    # recipes: functions returning a derivation
    #           the term recipes come from
    #           https://archive.fosdem.org/2024/schedule/event/fosdem-2024-3107-units-of-composition-recipes-overlays-and-packages/
    #           (some discussion I have not read at
    #           https://discourse.nixos.org/t/new-reader-finding-documentation-unnecessarily-confusing/40722/6

    portable = {
        packageBuilders = {
            inherit (self.native.${localSystem}.legacyPackages)
                writeTextFile writeText writeTextDir writeScript writeScriptBin
                concatTextFile concatText concatScript
                symlinkJoin;

            # TODO ideally we would have some sort of 'safe' mkDerivation here that
            #      can only produce portable packages.
        };
    };

    # NOTE: native is only always one system, but we still force using the system name
    # to make things unambiguous.
    native.${localSystem} = let
        pkgs = nixpkgs_nonflake {
            system = localSystem;
            config = nixpkgs_config;
        };
    in {
        legacyPackages = pkgs;
        packageBuilders = {
            inherit (pkgs.stdenv) mkDerivation;
            inherit (pkgs) writeShellScript writeShellScriptBin writeShellApplication;
        };
    };
    
    # Alias for cases in which we clearly want to run everything locally.
    # For instance for commands.
    local = self.native.${localSystem};

    qemu = let
        checksystem = system:
            if elem system platform.emulatedSystems
            then system
            else throw "Please add ${system} to binfmt.emulatedSystem" # TODO make this a warning?
            ;
        gensystem = system: let
            pkgs = nixpkgs_nonflake {
                inherit system;
                config = nixpkgs_config;
            };
            in {
                # Packages built using emulation.
                # Pro: matches the binary cache (if it exists), so should have to compile less.
                # Pro: installed packages are exactly as native. That's useful if we want to
                #      sometimes rebuild the system on the target system itself.
                # Con: if compilation is needed, it's slower than cross compilation.
                # Some more info:
                # https://discourse.nixos.org/t/error-building-a-raspberry-pi-image-using-nix-on-a-x86-64-system/37968/3
                # https://discourse.nixos.org/t/how-do-i-get-my-aarch64-linux-machine-to-build-x86-64-linux-extra-platforms-doesnt-seem-to-work/38106/2
                legacyPackages = pkgs;
            };
        in removeAttrs {
            x86_64-linux  = gensystem (checksystem "x86_64-linux");
            aarch64-linux = gensystem (checksystem "aarch64-linux");
        } [ localSystem ];

    cross = let
        gensystem = system: let
            pkgs = nixpkgs_nonflake {
                system = localSystem;
                crossSystem = system;
                config = nixpkgs_config;
            };
            in {
                # Packages built using cross compilation.
                # Pro: builds faster than emulated.
                # Con: cannot use the binary cache.
                # Con: cross compilation can leak and cause bugs sometimes?
                #      I read this but can't find it anymore.
                legacyPackages = pkgs;
            };
        in removeAttrs {
            x86_64-linux  = gensystem "x86_64-linux";
            aarch64-linux = gensystem "aarch64-linux";
        } [ localSystem ];

    packages = let
        # TODO: discover packages in attrsets and flatten them?
        #       remember: we only want to expose packages.${system}.${pkgname}, nothing deeper!
        # TODO: put functions that return a derivation in recipes? (this is hard to detect.)
        # TODO: do this at pin update time, because it is costly
        realPackages = pkgs: let
            select = attr: let tried = tryEval (nixpkgs_lib.isDerivation attr.value); in tried.success && tried.value;
        in filterAttrs select pkgs;
    in {
        # TODO same structure with native/qemu/cross as legacyPackages
    };

    lib = nixpkgs_lib // {
        nixosSystem = { modules, pkgs }:
            nixpkgs_nixos_lib_eval-config {
                system = null;
                lib = nixpkgs_lib; # don't let eval-config.nix reimport lib
                extraModules = []; # disable some env-dependent stuff
                modules = modules ++ [{
                    # We want nixosSystem to always get an explicit pkgs parameter.
                    # But we pass it modularly because the pkgs parameter of eval-config.nix is sort of deprecated.
                    nixpkgs.pkgs = pkgs;
                    
                    # TODO: check that nixpkgs checks the system of pkgs against nixpkgs.hostPlatform (usually in hardware-configuration.nix)
                    # If not, maybe this will help to produce a nice module option conflict error:
                    # nixpkgs.hostPlatform = pkgs.stdenv.hostPlatform.system;
                }];
            };
    };

    # inherit (nixpkgs_flake) nixosModules;
    
};
in self
